% Подсчет

## Повторение с заменой 

Подсчет чего-либо в макросе - удивительно хитрая задача.  Самое простое решение
- использовать замену и повторяющееся сопоставление с образцом.

```rust
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {0usize $(+ replace_expr!($tts 1usize))*};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

Такой способ прекрасно подходит для небольшого количества переменных, но скорее
всего *сломает компилятор*, когда их на входе будет 500 или больше. Представьте,
что вывод будет выглядеть как-то так:

```ignore
0usize + 1usize + /* ~500 `+ 1usize`s */ + 1usize
```

Компилятор должен разобрать это в AST, что, скорее всего, приведет к созданию
абсолютно несбалансированного двоичного дерева с 500+ уровнями глубины.

## Рекурсия

Есть старый подход - использовать рекурсию.

```rust
macro_rules! count_tts {
    () => {0usize};
    ($_head:tt $($tail:tt)*) => {1usize + count_tts!($($tail)*)};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

> **Заметьте**: По состоянию на `rustc` 1.2, у компилятора появляются  
*серьезные* проблемы с производительностью, если надо вывести большое число 
целочисленных переменных из неизвестного типа. Мы используем здесь переменные
типа `usize` для избежания такой проблемы.
>
> Если такой вариант не подходит (например, когда тип должен подставляться), вы
 можете помочь компилятору, используя `as` (*например* `0 as $ty`, `1 as $ty`,
  *и т.д.*).

Этот подход *работает*, но довольно быстро будет достигнут лимит рекурсии. В
отличие от подхода с повторениями, вы можете расширить количество переменных на
входе, сопоставляя несколько токенов за один раз.

```rust
macro_rules! count_tts {
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $_k:tt $_l:tt $_m:tt $_n:tt $_o:tt
     $_p:tt $_q:tt $_r:tt $_s:tt $_t:tt
     $($tail:tt)*)
        => {20usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $_f:tt $_g:tt $_h:tt $_i:tt $_j:tt
     $($tail:tt)*)
        => {10usize + count_tts!($($tail)*)};
    ($_a:tt $_b:tt $_c:tt $_d:tt $_e:tt
     $($tail:tt)*)
        => {5usize + count_tts!($($tail)*)};
    ($_a:tt
     $($tail:tt)*)
        => {1usize + count_tts!($($tail)*)};
    () => {0usize};
}

fn main() {
    assert_eq!(700, count_tts!(
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        
        // Повторение ломается где-то после этого места
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,

        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
        ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,, ,,,,,,,,,,
    ));
}
```

Такой способ будет работать вплоть до ~1,200 значений.

## Длина среза

Третий подход к решению проблемы — помочь компилятору сконструировать неглубокий
AST, который не приведет к переполнению стека. Можно создать массив и вызвать
его метод `len`.

```rust
macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}

macro_rules! count_tts {
    ($($tts:tt)*) => {<[()]>::len(&[$(replace_expr!($tts ())),*])};
}
# 
# fn main() {
#     assert_eq!(count_tts!(0 1 2), 3);
# }
```

Этот подход протестирован на 10000 токенах на входе и, возможно, будет работать
и дальше. *Обратной стороной* является то, что в Rust 1.2 он *не может* быть
использован для создания постоянного выражения. Хотя результат и может быть
оптимизирован до простой константы (при сборке в отладочном режиме он
компилируется так, что загружается из памяти), он все равно не может
использоваться в качестве константы (значение `const` или точный размер
массива).

Однако, если необходим неконстантный подсчет, это один из самых предпочтительных
методов.

## Подсчет через Enum

Этот подход может использоваться, если вам нужно посчитать набор взаимно
различных идентификаторов. К тому же результат этого подхода можно использовать
как константу.

```rust
macro_rules! count_idents {
    ($($idents:ident),* $(,)*) => {
        {
            #[allow(dead_code, non_camel_case_types)]
            enum Idents { $($idents,)* __CountIdentsLast }
            const COUNT: u32 = Idents::__CountIdentsLast as u32;
            COUNT
        }
    };
}
# 
# fn main() {
#     const COUNT: u32 = count_idents!(A, B, C);
#     assert_eq!(COUNT, 3);
# }
```

У этого метода есть два недостатка.  

Первый недостаток, как видно из кода выше - способность считать только
правильные идентификаторы (не являющиеся ключевыми словами) и эти идентификаторы
не могут повторяться.

Второй недостаток - этот подход *не совсем* чист. Если вы подставите
`__CountIdentsLast` на входе, то он сломается из-за дублирования вариантов в
`enum`.
