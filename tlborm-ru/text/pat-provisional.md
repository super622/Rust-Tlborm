% Предварительно

Этот раздел предназначен для паттернов или техник, которые имеют сомнительную
ценность, или которые могут иметь *слишком узкую* область применения для
включения их в основной список.

## Счеты

> **Предварительно**: нужны более привлекательные примеры. Несмотря на то что
важная часть макроса `Ook!`, относящаяся к поиску совпадений с вложенными
группами, *не* входящим в группы Rust, очень необычна, она может не
заслуживать включения в этот раздел.

> **Заметьте**: в этом разделе подразумевается понимание [спихиваемых накоплений](#push-down-accumulation) и [последовательных потребителей TT](#incremental-tt-munchers).

```rust
macro_rules! abacus {
    ((- $($moves:tt)*) -> (+ $($count:tt)*)) => {
        abacus!(($($moves)*) -> ($($count)*))
    };
    ((- $($moves:tt)*) -> ($($count:tt)*)) => {
        abacus!(($($moves)*) -> (- $($count)*))
    };
    ((+ $($moves:tt)*) -> (- $($count:tt)*)) => {
        abacus!(($($moves)*) -> ($($count)*))
    };
    ((+ $($moves:tt)*) -> ($($count:tt)*)) => {
        abacus!(($($moves)*) -> (+ $($count)*))
    };

    // Проверка получившегося результата на ноль.
    (() -> ()) => { true };
    (() -> ($($count:tt)+)) => { false };
}

fn main() {
    let equals_zero = abacus!((++-+-+++--++---++----+) -> ());
    assert_eq!(equals_zero, true);
}
```

Эта техника может использоваться в тех случаях, когда вам нужно отслеживать
изменения счетчика, начинающегося с чего-то близкого к нулю, и нужно
обладать следующими операциями:

* Увеличение на единицу.
* Уменьшение на единицу.
* Сравнение с нулем (или другой фиксированной, конечной величиной).

Значение *n* обозначает *n* экземпляров конкретного токена, входящего в группу.
Изменение выполняется рекурсией и [спихиваемыми накоплениями](#push-down-accumulation).
Предполагая, что используемый токен -`x`, операции выше реализуются по-следующему:

* Увеличение на единицу: совпадение с `($($count:tt)*)` заменяется на `(x $($count)*)`.
* Уменьшение на единицу: совпадение с `(x $($count:tt)*)` заменяется на `($($count)*)`.
* Сравнение с нулем: совпадение с `()`.
* Сравнение с единицей: совпадение с `(x)`.
* Сравнение с двойкой: совпадение с `(x x)`.
* *(и так далее...)*

Таким образом операции со счетчиком похожи на щелканье токенов туда и обратно,
как на счётах. [^abacus]

[^abacus]: Это крайне тонкое сравнение на самом деле скрывает *настоящую*
причину такого названия: избежать *еще одной* штуки со словом "токен" в
названии. Мы пытаемся избежать явления [семантического насыщения](https://en.wikipedia.org/wiki/Semantic_satiation)!

По правде говоря, эти операции *также* можно было бы назвать ["унарный подсчет"](https://en.wikipedia.org/wiki/Unary_numeral_system).

Если вам нужны отрицательные значения, то *-n* можно заменить на *n* экземпляров
*другого* токена.  В примере выше, *+n* представлено *n* `+` токенами, а *-m* -
*m* `-` токенами.

В этом случае операции немного усложняются; увеличение и уменьшение просто
меняют свое значение на противоположное, если счетчик отрицательный. Считая,
что `+` и `-` представляют положительный и отрицательный токены соответственно,
операции меняются следующим образом:

* Увеличение на единицу:
  * совпадение с `()`, заменяется на `(+)`.
  * совпадение с `(- $($count:tt)*)`, заменяется на `($($count)*)`.
  * совпадение с `($($count:tt)+)`, заменяется на `(+ $($count)+)`.
* Уменьшение на единицу:
  * совпадение с `()`, заменяется на `(-)`.
  * совпадение с `(+ $($count:tt)*)`, заменяется на `($($count)*)`.
  * совпадение с `($($count:tt)+)`, заменяется на `(- $($count)+)`.
* Сравнение с 0: совпадение с `()`.
* Сравнение с +1: совпадение с `(+)`.
* Сравнение с -1: совпадение с `(-)`.
* Сравнение с +2: совпадение с `(++)`.
* Сравнение с -2: совпадение с `(--)`.
* *(и так далее...)*

Заметьте, что пример выше объединяет некоторые из этих правил вместе (например,
он объединяет инкремент `()` и `($($count:tt)+)` в инкремент `($($count:tt)*)`).

Если вы хотите достать текущее *значение* счетчика, можно использовать обычный
[подсчет](../blk/README.html#counting). Для примера выше терминальные правила
можно заменить следующими:

```ignore
macro_rules! abacus {
    // ...

    // Эти правила выделяют счетчик как представление целого.
    (() -> ()) => {0};
    (() -> (- $($count:tt)*)) => {
        {(-1i32) $(- replace_expr!($count 1i32))*}
    };
    (() -> (+ $($count:tt)*)) => {
        {(1i32) $(+ replace_expr!($count 1i32))*}
    };
}

macro_rules! replace_expr {
    ($_t:tt $sub:expr) => {$sub};
}
```

> **<abbr title="Только для этого примера">ТДЭП</abbr>**: грубо говоря,
приведенная версия `abacus!` невообразимо сложна. Ее можно заменить на
гораздо более эффективную, использующую повторения, только в том случае,
если вам *не* надо нигде сопоставлять образец со значением счетчика в
макросе:


>
> ```ignore
> macro_rules! abacus {
>     (-) => {-1};
>     (+) => {1};
>     ($($moves:tt)*) => {
>         0 $(+ abacus!($moves))*
>     }
> }
> ```
