% Ook!

Этот макрос представляет собой реализацию [эзотерического языка
Ook!](http://www.dangermouse.net/esoteric/ook.html), которая изоморфна
[эзотерическому языку Brainfuck](http://www.muppetlabs.com/~breadbox/bf/).

Вычисления в языке организованы очень просто: память представляет собой массив
"ячеек" (размером, как минимум, 8 бит) переменной длины (как минимум, 30.000
"ячеек"). Указатель, находящийся в памяти, начинается с 0. Наконец, есть стек
выполнения (используемый для реализации циклов) и указатель на инструкцию
(команду) в программе, хотя они и относятся к среде выполнения, а не
непосредственно к выполняющейся программе.

Язык состоит всего из трех служебных слов: `Ook.`, `Ook?` и `Ook!`. Они
объединяются в пары, формируя 8 различных инструкций:

* `Ook. Ook?` - инкрементировать указатель.
* `Ook? Ook.` - декрементировать указатель.
* `Ook. Ook.` - инкрементировать значение в ячейке памяти, на которую указывает
 указатель.
* `Ook! Ook!` - декрементировать значение в ячейке памяти, на которую указывает
 указатель.
* `Ook! Ook.` - переписать значение из ячейки памяти, на которую указывает 
указатель, в стандартный вывод.
* `Ook. Ook!` - переписать значение из стандартного входа в ячейку памяти, на 
которую указывает указатель.
* `Ook! Ook?` - начать цикл.
* `Ook? Ook!` - перейти на начало цикла, если значение в ячейке памяти, на 
которую указывает указатель, не равно 0; иначе, продолжить.

Ook! интересен тем, что он является тьюринг-полным, что означает, что среда, в
которой вы можете реализовать его, *тоже* должна быть тьюринг-полной.

## Реализация

```ignore
#![recursion_limit = "158"]
```

На самом деле это минимальный лимит рекурсии, при котором скомпилируется пример,
приведенный в конце. Если вы хотите знать, что может быть таким фантастически
сложным, что может *оправдать* изменение лимита рекурсии в пять раз от
значения по умолчанию ... [попробуйте угадать](https://ru.wikipedia.org/wiki/Hello,_world!).

```ignore
type CellType = u8;
const MEM_SIZE: usize = 30_000;
```

Эти объявления нужно разместить здесь, чтобы убедиться, что они видимы для
развертывания макроса.[^*]

[^*]: Эти объявления *могли бы* быть определены внутри макроса, но тогда их бы 
пришлось явно передавать в каждом вызове макроса (из-за гигиены). Честно говоря,
к тому моменту как я понял, что мне *нужно* их определить, макрос был уже почти 
написан и ... ну, а *вам* бы хотелось все переделывать заново без особой на то 
важной причины?

```ignore
macro_rules! Ook {
```

Имя *по-хорошему* должно было быть `ook!` по правилам именования, но случай уж
был слишком хорош, чтобы пройти мимо них.

Правила для этого макроса разбиты на секции с использованием паттерна 
[Внутренние правила](../pat/README.html#internal-rules).

Первым идет правило `@start`, обрабатывающее настройки блока, в котором будет
происходить остальное развертывание. Здесь нет ничего интересного: мы определяем
некоторые переменные и вспомогательные функции, и затем запускаем основную часть
развертывания.

Несколько небольших замечаний:

* Мы разворачиваем в функцию, поэтому можем использовать `try!` для упрощения 
перехвата ошибок.
* Используем имена с подчеркиванием вначале для того, чтобы компилятор не ругался 
на неиспользуемые функции и переменные, если пользователь пишет Ook! для 
программы, у которой, например, нет I/O.

```ignore
    (@start $($Ooks:tt)*) => {
        {
            fn ook() -> ::std::io::Result<Vec<CellType>> {
                use ::std::io;
                use ::std::io::prelude::*;
    
                fn _re() -> io::Error {
                    io::Error::new(
                        io::ErrorKind::Other,
                        String::from("ran out of input"))
                }
                
                fn _inc(a: &mut [u8], i: usize) {
                    let c = &mut a[i];
                    *c = c.wrapping_add(1);
                }
                
                fn _dec(a: &mut [u8], i: usize) {
                    let c = &mut a[i];
                    *c = c.wrapping_sub(1);
                }
    
                let _r = &mut io::stdin();
                let _w = &mut io::stdout();
        
                let mut _a: Vec<CellType> = Vec::with_capacity(MEM_SIZE);
                _a.extend(::std::iter::repeat(0).take(MEM_SIZE));
                let mut _i = 0;
                {
                    let _a = &mut *_a;
                    Ook!(@e (_a, _i, _inc, _dec, _r, _w, _re); ($($Ooks)*));
                }
                Ok(_a)
            }
            ook()
        }
    };
```

### Разбор инструкций

Далее идут правила "выполнения", которые используется для разбора инструкций,
полученных со входа.

Общая форма таких правил - `(@e $syms; ($input))`. Как видно из `@start`,
`$syms` - это коллекция символов, необходимая для реализации программы: вход,
выход, массив памяти *и т.д.*. Мы используем [связывание ТТ](../pat/README.html#tt-bundling)
для передачи этих символов дальше, промежуточным правилам.

Первое правило заканчивает нашу рекурсию: если на входе у нас ничего нет -
останавливаемся.

```ignore
    (@e $syms:tt; ()) => {};
```

Дальше у нас идут правила *почти* для каждой инструкции. Для этого мы берем
инструкцию, подставляем вместо нее соответствующий код на Rust, затем рекурсивно
перемещаемся в конец входа: так, как описано в разделе [последовательный потребитель TT](../pat/README.html#incremental-tt-munchers).

```ignore
    // Инкремент указателя.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook? $($tail:tt)*))
    => {
        $i = ($i + 1) % MEM_SIZE;
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Декремент указателя.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook? Ook. $($tail:tt)*))
    => {
        $i = if $i == 0 { MEM_SIZE } else { $i } - 1;
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Инкремент значения, на которое указывает указатель.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook. $($tail:tt)*))
    => {
        $inc($a, $i);
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Декремент значения, на которое указывает указатель.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook! $($tail:tt)*))
    => {
        $dec($a, $i);
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Запись в вывод.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook. $($tail:tt)*))
    => {
        try!($w.write_all(&$a[$i .. $i+1]));
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
    
    // Чтение со входа.
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook. Ook! $($tail:tt)*))
    => {
        try!(
            match $r.read(&mut $a[$i .. $i+1]) {
                Ok(0) => Err($re()),
                ok @ Ok(..) => ok,
                err @ Err(..) => err
            }
        );
        Ook!(@e ($a, $i, $inc, $dec, $r, $w, $re); ($($tail)*));
    };
```

И тут мы подходим к более запутанным вещам. Этот код, `Ook! Ook?`, означает
начало цикла. Циклы Ook! транслируются в следующий код на Rust:

> **Замечание**: это *не* часть рабочего кода.
>
> ```ignore
> while memory[ptr] != 0 {
>     // Содержимое цикла
> }
> ```

*На самом деле* мы, конечно же, не можем сымитировать незаконченный цикл.
*Можно* было бы решить эту проблему, используя  [спихиваемые
накопления](../pat/README.html#push-down-accumulation), если бы это не приводило
к еще более глобальной проблеме: мы не можем, в принципе, *написать* *где бы то
ни было* `while memory[ptr] != {` из-за того, что в противном случае у нас бы
появилась лишняя "висячая" скобка.

Чтобы решить эту проблему, мы разделяем вход на две части: все, что *внутри*
цикла, и все, что *после* него. Правила `@x` берут на себя первое, `@s` -
второе.

```ignore
    (@e ($a:expr, $i:expr, $inc:expr, $dec:expr, $r:expr, $w:expr, $re:expr);
        (Ook! Ook? $($tail:tt)*))
    => {
        while $a[$i] != 0 {
            Ook!(@x ($a, $i, $inc, $dec, $r, $w, $re); (); (); ($($tail)*));
        }
        Ook!(@s ($a, $i, $inc, $dec, $r, $w, $re); (); ($($tail)*));
    };
```

### Извлечение цикла

Дальше идут `@x`, или правила "извлечения". Они отвечает за следующее - берут
хвост со входа и извлекают все содержимое внутри цикла. Общая форма этих правил:
`(@x $sym; $depth; $buf; $tail)`.

Назначение `$sym` такое же, как и выше. `$tail` - это вход, который нужно
разобрать, в то время как `$buf` - это [спихиваемое
накопление](../pat/README.html#push-down-accumulation), в который мы будем
складывать инструкции, находящиеся внутри цикла. Ну а как на счет `$depth`?

Сложности добавляет то, что циклы могут быть *вложенными*. Итак, мы должны как-
то отслеживать, на каком уровне вложенности мы находимся в данный момент. Нужно
следить очень внимательно, чтобы не остановить разбор слишком рано или слишком
поздно, а закончить его *вовремя*.[^right-in-time]

[^right-in-time]:
    Известный факт[^fact], что сказка "Маша и три медведя" - это на самом 
    деле аллегория на технику аккуратного лексического разбора.

[^fact]: И под "фактом" я подразумеваю "бесстыдное вранье".

Из-за того, что мы не можем выполнять арифметические действия в макросах, а
также видится неосуществимым, написать собственные правила совпадения со всеми
целыми числами (представьте надо написать такие правила для всех положительных
целых чисел), вместо этого вернемся к самому древнему и самому почтенному
методу счета в истории: счету на пальцах.

У макроса *нет* пальцев, поэтому используем вместо них
[счёты](../pat/README.html#abacus-counters). Если конкретно, будем использовать
`@` для каждого дополнительного уровня вложенности. Если мы будем хранить `@` в
группе, то сможем реализовать три нужные нам операции:

* Инкремент: `($($depth:tt)*)` заменяем на `(@ $($depth)*)`.
* Декремент:  `(@ $($depth:tt)*)` заменяем на `($($depth)*)`.
* Сравнение с нулем: сравнение с `()`.

Первое правило необходимо, чтобы найти совпадение с выражением `Ook? Ook!`,
заканчивающее цикл, который мы разбираем. В этом случае мы скармливаем
накопленное содержание цикла ранее определенным правилам `@e`.

Заметьте, что нам *не нужно* делать что-либо с оставшимся хвостом на входе (он
будет обрабатываться правилами `@s`).

```ignore
    (@x $syms:tt; (); ($($buf:tt)*);
        (Ook? Ook! $($tail:tt)*))
    => {
        // Внешний цикл заканчивается. Обрабатываем значения из буфера.
        Ook!(@e $syms; ($($buf)*));
    };
```

Дальше, у нас есть правила для входа и выхода из вложенных циклов. Они
изменяют счетчик и добавляет инструкции в буфер.

```ignore
    (@x $syms:tt; ($($depth:tt)*); ($($buf:tt)*);
        (Ook! Ook? $($tail:tt)*))
    => {
        // На один уровень глубже.
        Ook!(@x $syms; (@ $($depth)*); ($($buf)* Ook! Ook?); ($($tail)*));
    };
    
    (@x $syms:tt; (@ $($depth:tt)*); ($($buf:tt)*);
        (Ook? Ook! $($tail:tt)*))
    => {
        // На один уровень выше.
        Ook!(@x $syms; ($($depth)*); ($($buf)* Ook? Ook!); ($($tail)*));
    };
```

Наконец, у нас есть правило для "всего остального". Обратите внимание на
метапеременные `$op0` и `$op1`: как подразумевается в Rust, наш токен Ook! - это
всегда *два* токена в Rust: идентификатор `Ook` и другой токен. Таким образом,
мы можем найти все нецикличные инструкции по совпадению с `!`, `?` и `.` на
месте `tt`.

Мы не трогаем `$depth` и просто добавляем инструкции в буфер.

```ignore
    (@x $syms:tt; $depth:tt; ($($buf:tt)*);
        (Ook $op0:tt Ook $op1:tt $($tail:tt)*))
    => {
        Ook!(@x $syms; $depth; ($($buf)* Ook $op0 Ook $op1); ($($tail)*));
    };
```

### Пропуск цикла

*В целом* здесь происходит то же самое, что и в извлечении цикла, кроме того,
что мы не заботимся о *внутренностях* цикла (и, в связи с этим, нам не нужен
буфер накоплений). Все, что нам нужно - это знать, когда мы *прошли* мимо цикла.
В этом случае мы продолжаем обрабатывать вход, используя правила `@e`.

В связи с вышесказанным эти правила представлены без дальнейших объяснений.

```ignore
    // Конец цикла
    (@s $syms:tt; ();
        (Ook? Ook! $($tail:tt)*))
    => {
        Ook!(@e $syms; ($($tail)*));
    };

    // Вход во вложенный цикл.
    (@s $syms:tt; ($($depth:tt)*);
        (Ook! Ook? $($tail:tt)*))
    => {
        Ook!(@s $syms; (@ $($depth)*); ($($tail)*));
    };
    
    // Выход из вложенного цикла.
    (@s $syms:tt; (@ $($depth:tt)*);
        (Ook? Ook! $($tail:tt)*))
    => {
        Ook!(@s $syms; ($($depth)*); ($($tail)*));
    };

    // Инструкция, не связанная с циклами.
    (@s $syms:tt; ($($depth:tt)*);
        (Ook $op0:tt Ook $op1:tt $($tail:tt)*))
    => {
        Ook!(@s $syms; ($($depth)*); ($($tail)*));
    };
```

### Точка входа

Это единственное не-внутреннее правило.

Стоит отметить, что этот шаблон просто ищет совпадения по *всем* токенам,
переданным ему, и поэтому он *чрезвычайно опасен*. Любая ошибка может привести
к неправильному распознаванию всех правил выше, что может в свою очередь
привести к бесконечной рекурсии.

Когда вы пишете, изменяете или занимаетесь отладкой макроса как этот, будет
уместно временно подставить в начало что-то, вроде `@entry`. Это позволит
избежать случая с бесконечной рекурсией, и в случае ошибок приведет, по большей
части, к правильному их распознаванию.

```ignore
    ($($Ooks:tt)*) => {
        Ook!(@start $($Ooks)*)
    };
}
```

### Использование

Вот, наконец, и наша тестовая программа.

```ignore
fn main() {
    let _ = Ook!(
        Ook. Ook?  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook! Ook?  Ook? Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook?  Ook! Ook!  Ook? Ook!  Ook? Ook.
        Ook! Ook.  Ook. Ook?  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook?
        Ook! Ook!  Ook? Ook!  Ook? Ook.  Ook. Ook.
        Ook! Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook! Ook.  Ook! Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook.  Ook. Ook?  Ook. Ook?
        Ook. Ook?  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook?
        Ook! Ook!  Ook? Ook!  Ook? Ook.  Ook! Ook.
        Ook. Ook?  Ook. Ook?  Ook. Ook?  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook! Ook?  Ook? Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook?  Ook! Ook!  Ook? Ook!  Ook? Ook.
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook.
        Ook? Ook.  Ook? Ook.  Ook? Ook.  Ook? Ook.
        Ook! Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook! Ook.  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook.
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook!  Ook! Ook!  Ook! Ook!  Ook! Ook!
        Ook! Ook.  Ook. Ook?  Ook. Ook?  Ook. Ook.
        Ook! Ook.  Ook! Ook?  Ook! Ook!  Ook? Ook!
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook. Ook.  Ook. Ook.
        Ook. Ook.  Ook. Ook.  Ook! Ook.
    );
}
```

На выходе после запуска (после продолжительной паузы, во время которой
компилятор выполнит сотни рекурсивных развертываний макроса) получаем
следующее:

```text
Hello World!
```

Так мы показали ужасающую правду - `macro_rules!` является тьюринг-полным!

### В дополнение

Представленный выше код основан на макро-реализации изоморфного языка "Hodor!".
Manish Goregaokar затем [реализовал интерпретатор Brainfuck, используя макрос Hodor!](https://www.reddit.com/r/rust/comments/39wvrm/hodor_esolang_as_a_rust_macro/cs76rqk?context=10000). 
Таким образом, это интерпретатор  Brainfuck, написанный на Hodor!, который, в 
свою очередь, написан на  `macro_rules!`.

Легенда гласит, что после увеличения лимита рекурсии до *трех миллионов* и
запуска на *четыре дня*, он наконец выполнился.

...переполнением стека и падением. И по настоящий день, эзоязык-как-макрос 
остается абсолютно *нежизнеспособным* методом разработки на Rust.
