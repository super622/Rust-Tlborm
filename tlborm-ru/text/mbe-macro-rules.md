% macro_rules!

Рассказав обо всем другом, можем теперь рассмотреть сам  `macro_rules!`. Как
раньше было замечено, `macro_rules!` *представляет собой* расширение синтаксисa,
Это означает, что, *технически*, он не входит в синтаксис Rust. Он определяется
следующим образом:

```ignore
macro_rules! $name {
    $rule0 ;
    $rule1 ;
    // …
    $ruleN ;
}
```

Должно присутствовать *по меньшей мере* одно правило. Можно опустить точку с
запятой после последнего правила.

Каждое "`rule`" выглядит так:

```ignore
    ($pattern) => {$expansion}
```

Вообще, круглые и фигурные скобки могут обозначать любой тип группировки, но
принято, что круглые скобки ставят вокруг правила (pattern), а фигурные - вокруг
развертывания (expansion).

Если вам интересно, сам  `macro_rules!` разворачивается в ... *ничто*. По
крайней мере, ничего не появляется в AST; для регистрации нового макроса он
просто манипулирует внутренними структурами компилятора. Таким образом,
*формально*, вы можете использовать `macro_rules!` на любой позиции, в которой
подходит пустое развертывание.

## Совпадения с образцом

Когда вызывается макрос, интерпретатор `macro_rules!` проходит все правила, одно
за другим в лексическом порядке. Для каждого правила он пытается определить,
совпадает ли содержание на входе с `образцом` у каждого правила. Образец должен
совпасть *целиком*, чтобы считаться совпавшим.

Если вход совпадает с образцом, вызов заменяется на `развертывание`; иначе,
пробуется следующее правило. Если ни одно из правил не совпало, развертывание
макроса вызывает ошибку.

Самый простой пример с пустым образцом:

```ignore
macro_rules! four {
    () => {1 + 3};
}
```

Этот образец считается совпавшим тогда и только тогда, когда вход тоже будет
пустым (*например*, `four!()`, `four![]` или `four!{}`).

Заметьте, что символы группировки (скобки) при вызове макроса *не*
сопоставляются с образцом. Это означает, что вы можете вызвать макрос как
`four![]`, и он все равно совпадет. Рассматривается только *содержимое* на
входе.

Образцы также могут содержать деревья литеральных токенов, для совпадения с
которыми последовательность на входе должна быть точно такой же. Образец в этом
случае указывается как обычное дерево токенов. Например, для того, чтобы образец
совпал с `4 fn ['spang "whammo"] @_@`, вам нужно написать:

```ignore
macro_rules! gibberish {
    (4 fn ['spang "whammo"] @_@) => {...};
}
```

Вы можете использовать любые деревья токенов, какие только сможете написать.

## Метапеременные

Образцы могут содержать метапеременные (captures). Это позволяет проверять вход
на совпадение с образцом, основываясь на некоторой общей категории грамматики,
получая преобразованный в переменную результат, который в дальнейшем может быть
подставлен на выход.

Метапеременные обозначаются знаком доллара (`$`), за которым следуют
идентификатор, двоеточие (`:`), и, наконец, тип метапеременной, который должен
быть одним из следующих:

* `item`: элемент - например, функция, структура, модуль и т.д.
* `block`: блок (например, блок утверждений или выражений, окруженный фигурными 
скобками)
* `stmt`: утверждение
* `pat`: образец
* `expr`: выражение
* `ty`: тип
* `ident`: идентификатор
* `path`: путь (например, `foo`, `::std::mem::replace`, `transmute::<_, int>`, …)
* `meta`: мета элемент; то, что находится внутри атрибутов `#[...]` и `#![...]` 
* `tt`: одиночное дерево токенов

Вот пример макроса, который захватывает метапеременную на входе как выражение:

```ignore
macro_rules! one_expression {
    ($e:expr) => {...};
}
```

Метапеременные по максимуму используют парсер компилятора Rust, гарантируя свою
"корректность" во всех случаях. Метапеременная типа `expr` *всегда* захватывает
полное правильное выражение для той версии Rust, которая выполняет компиляцию.

Вы можете смешивать деревья литеральных токенов и метапеременные с небольшими
ограничениями (объясняются ниже).

Метапеременная `$name:kind` может быть подставлена в развертывание через
`$name`. Пример:

```ignore
macro_rules! times_five {
    ($e:expr) => {5 * $e};
}
```

В большинстве своем метапеременные заменяются на законченные узлы AST, как и
развертывания макроса. Это означает, что неважно, какие выражения из токенов
захвачены в метапеременной `$e`, она в любом случае будет интерпретироваться как
одно, законченное выражение.

У вас также может быть несколько метапеременных в одном образце:

```ignore
macro_rules! multiply_add {
    ($a:expr, $b:expr, $c:expr) => {$a * ($b + $c)};
}
```

## Повторения

Образцы могут содержать повторения. Это позволяет определить совпадения для
связки токенов. Общая форма повторений - `$ ( ... ) sep rep`.

* `$` - знак доллара.
* `( ... )` - повторяющийся образец в скобках .
* `sep` - разделитель (*необязательный параметр*).  Часто можно встретить `,` и
`;`.
* `rep` - контроль повторений (*обязательный параметр*). В данный момент это 
может быть `*` (обозначающий ноль или более повторений) или `+` (обозначающий 
одно или более повторений). Вы не можете определить "ноль или одно" или любое 
другое более конкретное число повторений.

Повторения могут содержать любые правильные образцы, включая деревья литеральных
токенов, метапеременные и другие повторения.

Повторения используют такой же синтаксис и в развертывании.

Например, ниже макрос, который преобразует каждый элемент в строку. Он ищет
совпадения с нулем или более выражений, разделенных запятой, и разворачивает их
в выражение, которое создает вектор.

```rust
macro_rules! vec_strs {
    (
        // Начало повторения:
        $(
            // Каждое повторение должно содержать выражение...
            $element:expr
        )
        // ...разделенное запятыми...
        ,
        // ...ноль или более раз.
        *
    ) => {
        // Заключаем разложение в скобки (блок), таким образом, 
        // можем использовать несколько утверждений.
        {
            let mut v = Vec::new();

            // Начало повторения:
            $(
                // Каждое повторение будет содержать утверждение ниже, в котором
                // $element будет заменен на соответствующее выражение.
                v.push(format!("{}", $element));
            )*

            v
        }
    };
}
# 
# fn main() {
#     let s = vec_strs![1, "a", true, 3.14159f32];
#     assert_eq!(&*s, &["1", "a", "true", "3.14159"]);
# }
```
