% Области видимости

Область видимости задается интуитивно понятным способом. Во-первых, макросы
видимы в под-модулях, что отличает их от всего остального в языке.

```rust
macro_rules! X { () => {}; }
mod a {
    X!(); // определен
}
mod b {
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

> **Внимание**: Для всех примеров их этого раздела, помните, что все они *ведут
 себя одинаково*, даже если модули располагаются в разных файлах.

Во-вторых, макросы доступны *только* после их определения, что *также* отличает
их от всего остального. Обратите внимание на этот пример, который демонстрирует,
что макросы не "поднимаются" из своей области видимости:

```rust
mod a {
    // X!(); // не определен
}
mod b {
    // X!(); // не определен
    macro_rules! X { () => {}; }
    X!(); // определен
}
mod c {
    // X!(); // не определен
}
# fn main() {}
```

Даже если вынести макрос наружу, эта зависимость от лексического порядка все
равно проявится:

```rust
mod a {
    // X!(); // не определен
}
macro_rules! X { () => {}; }
mod b {
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

В то же время, внутри самих макросов эта зависимость *отсутствует*:

```rust
mod a {
    // X!(); // не определен
}
macro_rules! X { () => { Y!(); }; }
mod b {
    // X!(); // определен, но Y! - не определен
}
macro_rules! Y { () => {}; }
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

Макросы могут быть экспортированы из модуля с помощью атрибута `#[macro_use]` .

```rust
mod a {
    // X!(); // не определен
}
#[macro_use]
mod b {
    macro_rules! X { () => {}; }
    X!(); // определен
}
mod c {
    X!(); // определен
}
# fn main() {}
```

Заметьте, что это может работать несколько странным образом из-за того, что
идентификаторы в макросе (включая и другие макросы внутри) разрешаются только
после развёртывания:

```rust
mod a {
    // X!(); // не определен
}
#[macro_use]
mod b {
    macro_rules! X { () => { Y!(); }; }
    // X!(); // определен, но Y! - не определен
}
macro_rules! Y { () => {}; }
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

Еще одной сложностью является то, что  `#[macro_use]`, применяемый к `extern
crate`, *не* ведет себя таким образом: он фактически *поднимает* макросы в
начало модуля. Поэтому, считая, что `X!` определен в `extern crate mac`:

```ignore
mod a {
    // X!(); // определен, но Y! - не определен
}
macro_rules! Y { () => {}; }
mod b {
    X!(); // определен, как и Y!
}
#[macro_use] extern crate macs;
mod c {
    X!(); // определен, как и Y!
}
# fn main() {}
```

И последнее, нужно помнить, что поведение макросов внутри областей видимости
определяется также как и у *функций*, за исключением `#[macro_use]` (смотри
выше):

```rust
macro_rules! X {
    () => { Y!() };
}

fn a() {
    macro_rules! Y { () => {"Hi!"} }
    assert_eq!(X!(), "Hi!");
    {
        assert_eq!(X!(), "Hi!");
        macro_rules! Y { () => {"Bye!"} }
        assert_eq!(X!(), "Bye!");
    }
    assert_eq!(X!(), "Hi!");
}

fn b() {
    macro_rules! Y { () => {"One more"} }
    assert_eq!(X!(), "One more");
}
# 
# fn main() {
#     a();
#     b();
# }
```

Учитывая эти правила для областей видимости, общим советом будет, ставить все
макросы наверх перед всем остальным в корневом модуле. Это гарантирует,
что они будут доступны *везде*.
