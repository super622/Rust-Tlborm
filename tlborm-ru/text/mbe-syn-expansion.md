% Развертывание

Развертывание - это относительно несложная штука. В какой-то момент *после*
создания AST, но перед тем, как начать создавать семантическое представление
программы, компилятор развернет все макросы.

Этот процесс включает в себя проход AST, определение мест вызовов макросов и
замены их на развертывание. В случае расширений синтаксиса, не связанных с
макросами, то, *как* компилятор их разворачивает, зависит от самих
синтаксических расширений. Таким образом, расширения синтаксиса проходят через
*точно такой же* процесс развертывания, как и макросы.

Когда компилятор выполняет расширение синтаксиса, он ожидает, что, исходя из
контекста, результат можно будет разобрать во что-то из известного ему списка
синтаксических элементов. Например, если вы вызываете макрос внутри модуля,
компилятор разберет результат в узел AST, представляющий элемент. Если вызвать
макрос на позиции выражения, компилятор разберет результат в узел AST,
представляющий выражение.

Компилятор, на самом деле, может развернуть расширение синтаксиса в одно из
следующего:

* выражение,
* паттерн,
* ноль или больше элементов,
* ноль или больше элементов `impl`,
* ноль или больше утверждений.

Другими словами, результат, в который разворачивается макрос определяет то,
*где* вы можете его вызвать.

Компилятор берет узел AST и полностью заменяет узел вызова макроса, на то, во
что он разворачивается. *Это структурная операция*, а не текстовая!

Например у нас есть следующее:

```ignore
let eight = 2 * four!();
```

Мы можем показать часть AST таким образом:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ Macro      │
     │ val: 2 │                 │ name: four │
     └────────┘                 │ body: ()   │
                                └────────────┘
```

Исходя из контекста, `four!()` *должен* развернуться в выражение (инициализаторы
могут быть *только* выражением). Поэтому, чем бы ни было реальное развертывание,
оно будет интерпретироваться как законченное выражение. В данном случае мы будем
считать, что `four!` определено так, что разворачивается в выражение `1 + 3`.  В
итоге, результат развертывания можно показать так:

```text
┌─────────────┐
│ Let         │
│ name: eight │   ┌─────────┐
│ init: ◌     │╶─╴│ BinOp   │
└─────────────┘   │ op: Mul │
                ┌╴│ lhs: ◌  │
     ┌────────┐ │ │ rhs: ◌  │╶┐ ┌─────────┐
     │ LitInt │╶┘ └─────────┘ └╴│ BinOp   │
     │ val: 2 │                 │ op: Add │
     └────────┘               ┌╴│ lhs: ◌  │
                   ┌────────┐ │ │ rhs: ◌  │╶┐ ┌────────┐
                   │ LitInt │╶┘ └─────────┘ └╴│ LitInt │
                   │ val: 1 │                 │ val: 3 │
                   └────────┘                 └────────┘
```

Можно также написать это так:

```ignore
let eight = 2 * (1 + 3);
```

Заметьте, что мы добавили скобки, *несмотря на то, что* их не было в
развертывании. Помните, что компилятор всегда трактует развертывание макроса,
как законченный узел AST, а **не** как простую последовательность токенов.
Говоря по-другому, даже если вы не обернули сложное выражение в скобки,
компилятор все равно "правильно" интерпретирует результат или поменяет порядок
вычислений.

Важно понимать, что развертывания макросов считаются узлами AST. Последствия
этого такие:

* В дополнении к тому, что есть ограниченный набор *мест вызовов*, макросы могут
 разворачиваться *только* в тот тип узла AST, который *ожидает парсер* в этом
 месте. 
* Вследствие вышеизложенного - макросы *никогда* не могут развернуться в
 незаконченное выражение или синтаксически неправильную конструкцию.

Нужно знать и еще одну вещь про развертывание: что происходит, если расширение
синтаксиса разворачивается во что-то, содержащее  *другой* вызов расширения
синтаксиса. Например, определим другое описание `four!`; что произойдет, если он
развернется в `1 + three!()`?

```ignore
let x = four!();
```

Разворачивается в:

```ignore
let x = 1 + three!();
```

Компилятор ищет в получившемся результате развертывания дополнительные вызовы
макросов и разворачивает их. Поэтому после второго развертывания получится
следующее:

```ignore
let x = 1 + 3;
```

Вывод из этого такой - развертывание осуществляется "проходами"; столько,
сколько нужно, чтобы полностью развернуть все вызовы.

Хотя, *немного не так*.  На самом деле компилятор ограничивает количество таких
рекурсивных проходов, которые он выполнит перед тем, как сдастся. Это называется
лимит рекурсии макросов и, по умолчанию, равен 32. Если 32-ое развёртывание
содержит вызов макроса, компилятор прервет свою работу с ошибкой, сообщающей,
что лимит рекурсии исчерпан.

Этот лимит можно увеличить с помощью атрибута `#![recursion_limit="…"]`, однако
это *необходимо* делать для всего контейнера. Обычно, рекомендуется стараться
удерживать макросы в этих границах.
