% Приведение к AST

Парсер Rust не очень силен в подстановках `tt`. Проблемы могут возникнуть, когда
парсер ожидает особенную грамматическую конструкцию, а *вместо этого* находит
кучу подставленных `tt` токенов. Он очень часто просто *сдается*, вместо того,
чтобы попытаться их разобрать. В этих случаях необходимо применить приведение к
AST.

```rust
# #![allow(dead_code)]
# 
macro_rules! as_expr { ($e:expr) => {$e} }
macro_rules! as_item { ($i:item) => {$i} }
macro_rules! as_pat  { ($p:pat) =>  {$p} }
macro_rules! as_stmt { ($s:stmt) => {$s} }
# 
# as_item!{struct Dummy;}
# 
# fn main() {
#     as_stmt!(let as_pat!(_) = as_expr!(42));
# }
```

Эти приведения часто используются со [push-down-accumulation] для
того, чтобы парсер обработал последнее выражение `tt` как особый вид
грамматической конструкции.

Помните, что представленный набор макросов определяется тем, во что они могут
разворачиваться, а *не* тем, какие метапеременные они могут захватывать. У нас
не получится создать макрос `as_ty!`, из-за того что мы не можем написать
макрос, который появится на позиции типа [^issue-27245], .

[push-down-accumulation]: pat-push-down-accumulation.html

[^issue-27245]: Смотри [Issue #27245](https://github.com/rust-lang/rust/issues/27245).
