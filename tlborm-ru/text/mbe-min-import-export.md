% Импорт/Экспорт

Расширить область видимости макроса можно двумя способами. Первый - использовать
атрибут `#[macro_use]`. Его можно применять *и* к "mod", и к "extern crate".
Например:

```rust
#[macro_use]
mod macros {
    macro_rules! X { () => { Y!(); } }
    macro_rules! Y { () => {} }
}

X!();
#
# fn main() {}
```

Второй способ - используя атрибут `#[macro_export]`, можно экспортировать макрос
из текущего контейнера. Будьте внимательны, этот способ *игнорирует* все области
видимости.

Допустим, что библиотека `macs` выглядит так:

```ignore
mod macros {
    #[macro_export] macro_rules! X { () => { Y!(); } }
    #[macro_export] macro_rules! Y { () => {} }
}

// X! и Y! *не* определены здесь, но всё равно *экспортируются*,
// несмотря на то, что `mod macros` является приватным.
```

Следующий код работает, как и ожидается:

```ignore
X!(); // X определен
#[macro_use] extern crate macs;
X!();
# 
# fn main() {}
```

Заметьте, что *только* в корневом модуле рядом с "extern crate" вы можете
использовать `#[macro_use]`.

Если макросы импортируются из "extern crate", можно контролировать *какой*
именно макрос импортируется. Можно использовать эту возможность, чтобы избежать
раздутия пространства имен, или чтобы переопределить какой-либо конкретный
макрос, например, так:

```ignore
// Импортируем  *только* макрос `X!` .
#[macro_use(X)] extern crate macs;

// X!(); // X определен, а Y! не определен

macro_rules! Y { () => {} }

X!(); // X определен, и Y! определен

fn main() {}
```

При экспортировании макросов из контейнера, часто бывает полезным ссылаться на
не-макросные имена, принадлежащие этому контейнеру. Контейнеры могут
переименовываться, поэтому есть служебная переменная подстановки: `$crate`. Она
*всегда* будет разворачиваться в префикс абсолютного пути к контейнеру, в
котором содержится экспортируемый макрос (*например*, `:: macs`).

Заметьте, что такой подход *не* работает для самих макросов, потому что они не
используют каким бы то ни было образом обычные правила разрешения имен. Поэтому,
чтобы сослаться на соответствующий макрос внутри вашего контейнера, нельзя
написать `$crate::Y!`. На данный момент в связи с этими особенностями *нельзя*
гарантировать, что любой ваш макрос будет доступен при импорте в другой
контейнер.

Чтобы избежать конфликтов, рекомендуется *всегда* использовать абсолютные пути к
не-макросным именам, *в том числе* и к именам из стандартной библиотеки.
